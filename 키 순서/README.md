이 기록을 시작하게 된 계기이자 SSAFY에서 처음 본 A형 취득 시험에서 나왔던 문제이다.
https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWXQsLWKd5cDFAUo

문제를 간략히 설명하자면
서로 키가 다른 N명의 학생의 키 순서를 비교하는 것이다. 두 학생의 키를 비교한 결과가 M개 주어질 때, 키 순서를 정확히 알 수 있는 학생수를 구하는 것이다.
M = N * (N - 1)/2라면 모든 학생을 서로 비교하게 되므로 모든 학생의 키 순서를 알 수 있지만, 그보다 작을 때는 일부 학생만 키 순서를 알 수 있게 된다.
a, b, c 세 학생이 있을 때, a < b, a < c라고 하면, b와 c의 관계는 알 수 없기 때문에 키 순서를 알 수 있는 학생은 a 한 명 뿐이다.

처음에는 문제에서 주어진 그래프를 활용해 bfs를 이용해 풀려고 했다. 대소를 비교한 입력들 (a b  //a < b라는 의미)이 주어졌을 때,
a에서 b로 가는 간선을 추가해 만든 그래프에서 bfs를 수행하며 자신보다 작은 노드의 개수를 세려고 했다.
A 노드에서 B노드로 탐색을 한다고 하자. A에서 자신보다 작은 노드의 수를 넘겨주면, 이 노드를 통해 방문한 B 노드에는 A노드보다 작은 노드와 A노드가 있으니까
A노드보다 하나 더 많게 하면 된다.

하지만 문제가 있었다. A노드가 B, C와 각각 이어져있고, B, C는 D와 이어져있다고 하면 자기보다 작은 노드의 수는
A: 0, B: 1, C: 1이다. 그런데 위 방법대로 D를 세면 A를 두번 세어 D: 4가 된다.
여기서 이 노드가 어떤 노드보다 큰지 알아야 정확하게 셀 수 있다고 생각했다.

그런데 이를 배열을 이용해 표시하게되면 너무 많은 메모리를 사용하게 된다. 2 <= N <= 500 이므로  500 * 500의 공간이 필요하고, 이를 비교할 때도 매번 N번의 비교가 필요하기 때문에
시간초과가 날 거라고 생각했다.
그래서 시간초과가 나지 않으면서 중복을 고려할 수 있는 방법을 생각하다가 bitwise연산을 생각했다.
각 학생마다 500개의 bit를 주고, i번째 학생의 j번째 bit는 i번째 학생과 j번째 학생의 관계를 의미하는 것이다.
위에서 봤던 예시를 다시 보면, B학생과 C번째 학생은 A번째 bit가 1이고, D번째 학생을 볼 때는 B번째 bit | C 번째 bit | B의 bit들 | C의 bit들이 되어 A, B, C번째 bit가 1이 된다.
중복도 체크할 수 있으면서 bitwise 연산으로 빠르게 계산할 수 있어 효율적일 것이라고 생각했다.

