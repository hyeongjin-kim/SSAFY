이 기록을 시작하게 된 계기이자 SSAFY에서 처음 본 A형 취득 시험에서 나왔던 문제이다.
https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWXQsLWKd5cDFAUo

문제를 간략히 설명하자면
서로 키가 다른 N명의 학생의 키 순서를 비교하는 것이다. 두 학생의 키를 비교한 결과가 M개 주어질 때, 키 순서를 정확히 알 수 있는 학생수를 구하는 것이다.
M = N * (N - 1)/2라면 모든 학생을 서로 비교하게 되므로 모든 학생의 키 순서를 알 수 있지만, 그보다 작을 때는 일부 학생만 키 순서를 알 수 있게 된다.
a, b, c 세 학생이 있을 때, a < b, a < c라고 하면, b와 c의 관계는 알 수 없기 때문에 키 순서를 알 수 있는 학생은 a 한 명 뿐이다.

처음에는 문제에서 주어진 그래프를 활용해 bfs를 이용해 풀려고 했다. 대소를 비교한 입력들 (a b  //a < b라는 의미)이 주어졌을 때,
a에서 b로 가는 간선을 추가해 만든 그래프에서 bfs를 수행하며 자신보다 작은 노드의 개수를 세려고 했다.
A 노드에서 B노드로 탐색을 한다고 하자. A에서 자신보다 작은 노드의 수를 넘겨주면, 이 노드를 통해 방문한 B 노드에는 A노드보다 작은 노드와 A노드가 있으니까
A노드보다 하나 더 많게 하면 된다.

하지만 문제가 있었다. A노드가 B, C와 각각 이어져있고, B, C는 D와 이어져있다고 하면 자기보다 작은 노드의 수는
A: 0, B: 1, C: 1이다. 그런데 위 방법대로 D를 세면 A를 두번 세어 D: 4가 된다.
여기서 이 노드가 어떤 노드보다 큰지 알아야 정확하게 셀 수 있다고 생각했다.

그런데 이를 배열을 이용해 표시하게되면 너무 많은 메모리를 사용하게 된다. 2 <= N <= 500 이므로  500 * 500의 공간이 필요하고, 이를 비교할 때도 매번 N번의 비교가 필요하기 때문에
시간초과가 날 거라고 생각했다.

그래서 시간초과가 나지 않으면서 중복을 고려할 수 있는 방법을 생각하다가 bitwise연산을 생각했다.
각 학생마다 500개의 bit를 주고, i번째 학생의 j번째 bit는 i번째 학생과 j번째 학생의 관계를 의미하는 것이다.

위에서 봤던 예시를 다시 보면, B학생과 C번째 학생은 A번째 bit가 1이고, D번째 학생을 볼 때는 B번째 bit | C 번째 bit | B의 bit들 | C의 bit들이 되어 A, B, C번째 bit가 1이 된다.
중복도 체크할 수 있으면서 bitwise 연산으로 빠르게 계산할 수 있어 효율적일 것이라고 생각했다.

이런 식으로 세서 A학생보다 작은 학생들, A학생들보다 큰 학생들을 모두 세었을 때, N-1명이면 A학생의 순서를 알 수 있다 라고 생각했다.

전체적인 흐름을 요약하면

root들(자신보다 작은 학생이 없는 노드들)에서 탐색해서 모든 노드들에 대해 자신보다 작은 노드들을 세고,
leaf들(자신보다 큰 학생이 없는 노드들)에서 탐색해서 모든 노드들에 대해 자신보다 큰 노드를 세고,

이를 합쳐 이 수가 N-1인가 확인하면 된다.

마지막에 자신보다 큰 학생과 작은 학생이 이 N-1명이라는 것을 세는게 살짝 머리를 써야 했는데, 순위를 알 수 있는 학생들의 bit는 다음과 같다.

0000...011...110111..110


         N     i      0
        
가장 처음 1이 등장하는 곳이 N번째이고, 쭉 1이 이어지다가 자기 자신을 의미하는 i번째는 0이 있고, 다시 1이 이어지다 0번째에는 0이 나온다.(학생번호가 1부터 시작해서)

0000...011...111111..110


         N     i      0

        
그래서 위와 같이 0번을 제외한 N개의 bit가 모두 1인 예시를 만들고, 학생마다 자기 자신을 의미하는 i번째를 1로 바꾼 뒤 이 예시와 비교해서 일치하면 순위를 알 수 있다는 결론이 된다.

그리고 탐색을 해야할 때도 주의할 점이 있는데, 해당 노드보다 작은 노드(또는 큰 노드)에 대한 정보를 모두 수집한 뒤에 탐색을 해야한다는 것이다.
a < c, b < c, c < d 라고 할 때, a - c 간선을 통해 c를 탐색한 뒤,  c - d 간선을 통해 d를 탐색하면 b에 대한 정보가 누락된다. 나중에  b - c간선을 통해 c의 정보는 업데이트 되지만,d는 업데이트되지 않는다.

노드들을 한 번만 방문해 시간을 줄이는 것이 목적이기에, 여러번 방문하지 않도록 해당 노드에 대한 정보를 모두 탐색한 뒤에 해당 노드를 탐색하면 된다.

이렇게 했을 때 메모리도 적게 쓰고 해결할 수 있었다.
