토요일에 B형 검정을 치고 왔다.
문제는 그동안 B형 검정을 준비하기 위해 풀었던 문제들에 비해서는 그렇게 어렵지 않았다.
N개의 도시와 이들을 잇는 M개의 도로가 존재한다. 각 도시에는 전기차가 달리기 위한 단위 거리당 충전 비용이 C가 존재한다. (5 <= N <= 300, 5 <= M <= 2000, 1 <= C <= 2000)
도로에는 고유의 ID가 주어져있고, 출발 도시와 도착 도시가 정해져있다. (1 <= ID <= 10억)

A도시에서 출발해서 B 도시로 가는데 똑같이 A에서 출발해서 B로 가는 도로는 유일하고 같은 도시로 다시 돌아오는 도로는 없다.

전기차는 충전 용량이 무한대이기에 가격이 싸다면 미리 충전하는 것이 유리하다.

이 문제에서 요구했던 것은 세가지이다.
ADD : 새로운 도로를 추가한다. 도로 ID, 출발도시, 도착 도시, 거리가 주어진다.(ID는 중복되지 않고 이미 존재하는 같은 도시 쌍을 같은 방향으로 있는 도로가 있다면 그런 도로는 주어지지 않는다.)
REMOVE : 주어진 ID를 가진 도로를 삭제한다. 존재하지 않는 도로 ID는 주어지지 않는다.
COST : 출발 도시 A 에서 도착 도시 B까지 가는데 필요한 최소 충전 비용을 반환한다. 도착도시로 갈 수 없다면 -1을 반환한다.

우선 그동안 B형 특강에서 배웠던 대로 어떤 자료구조나 알고리즘을 사용하는데 있어서 그 이유를 설명할 수 있도록 근거를 생각하면서 풀었다.

1. 도로의 생성과 삭제
    도로의 생성은 그렇게 어렵지 않다. 도로에 대한 모든 정보를 주기 때문에 그래프를 표현한 방식에 도로를 추가하는 것이 전부이다.
    생각해야하는 것은 삭제이다. 삭제의 경우 도로의 ID만 주어진다. ID만 가지고 특정 도로에 접근이 가능해야 한다는 것이다.
    이 점 때문에 그래프를 인접 리스트가 아닌 인접 배열로 구현했다. 이를 인접 리스트로 구현하는 것이 불편하다고 생각했다.
	인접 리스트로 한 뒤, 이 노드의 포인터를 ID로 접근할 수 있도록 하면 가능할 수도 있겠지만, ID로 접근해 삭제하는 매커니즘 상, 원하는 도로에 쉽게 접근이 가능해야 한다고 생각해서
	인접리스트가 불리하다고 판단했다.

 	그래서 나는 이를 인접 배열로 구현하였다. 왜냐하면 N이 최대 300으로 작아 인접 배열의 크기가 300 * 300 이기 때문에 과도한 공간차지라는 단점을 충분히 커버할 수 있다고 생각했다.
    인접 배열의 특징 상 출발 도시와 도착 도시만 알면 해당 도시의 정보에 빠르게 접근할 수 있기 때문에 유리하다. 인접 배열에는 해당 도로의 거리를 저장했다.
    다만, ID를 가지고 원하는 위치의 도로에 접근이 가능해야 한다. 이를 만약 배열로 구현한다면 1 ~ 10억의 위치가 필요하기 때문에 너무 큰 용량이 필요하다.
   	그래서 존재하는 위치만 저장할 수 있는 unordered_map을 사용했다. key로 ID를, value로 도로의 좌표 (a, b)로 해 ID만으로 좌표를 얻을 수 있고
  	이를 가지고 인접 배열에서 해당 도로의 길이를 얻을 수 있게 했다.

2. 최소 비용 루트 탐색
   	이 문제에서 가장 중요한 부분이자 어려운 부분이고 이 문제를 틀리게 된 이유이다. 최단 거리를 구하는 알고리즘은 다익스트라 알고리즘이 유명하지만 이 문제는 단순한 다익스트라 알고리즘으로는
   	답을 찾을 수 없다. 그 이유에는 여러가지가 있지만 먼저 필요한 비용의 계산이 단순한 거리 합산이 아니기 때문이다. 그래서 우선순위 큐에 삽입할 때 세가지 요소를 묶어 삽입했다.
	지금까지의 총 비용, 지금까지 있었던 도시 중 가장 저렴한 충전 비용, 현재 도시의 위치이다.
   	우선 순위 큐를 사용한 이유는 현재 방문할 수 있는 노드들 중 가장 저렴한 것을 먼저 찾아 최소 비용을 찾기 위해서다.
	처음에는 이들을 담은 구조체를 선언하고, operator <를 overloading을 이용하려 했으나, priority queue가 이런 식의 overloading을 지원하지 않는다는 것을 몰라서 실패했다.
   	나중에 찾아보니 priority queue는 비교 연산자로 클래스를 사용하기 때문에 클래스나 구조체로 비교하는 것을 따로 만들어 큐를 생성할 때 인자로 넘겼어야 했다.
	그래서 이를 tuple로 해결했다. tuple은 이미 tuple끼리 비교하는 연산자가 기본적으로 정의되어있기 때문이다.
	priority queue는 우선순위가 높은 것을 먼저 접근하게 한다. 우리는 최소 비용을 찾고 있고, 가능하다면 빠르게 이를 찾고 싶다.
	tuple은 인자를 순서대로 비교한다. 첫번째 인자를 비교하고, 같다면 두번째를 비교하고, 같다면 세번째를 비교한다.
	그래서 (-현재까지 누적 비용), (-지금까지의 최소 충전 비용), (현재 위치)순으로 저장해서 가장 누적 비용이 적은 루트, 그 중에서도 가장 충전 비용이 싼 쪽으로 해 최적화했다.
	여기까지가 시험을 볼 때 구현한 내용이었는데 내 코드로는 일부 테스트 케이스만 통과했다. 그래서 시험이 끝나고 나서 같은 반이었던 준휘님께 카톡으로 여쭤봤다.(감사합니다)

 	문제는 다익스트라였다. 다익스트라는 이미 방문한 노드라면 거리를 비교해서 거리가 더 짧은 쪽을 선택한다. 하지만 이 문제에서는 거리가 더 짧다고 더 좋은 루트라고 단정할 수 없다.
	그 이유는 미리 충전이 가능하기 때문이다. 미리 충전이 가능하기 때문에 앞으로 나올 도로의 거리에 따라서 지금까지는 더 비싼 루트였지만, 나중에는 어떻게 될 지 모른다는 것이다.
	이를 해결하기 위해서는
	a. 이미 방문한 노드더라도 루트가 달라 기존 루트보다 더 적은 최소 비용을 가지고 있다면 큐에 추가한다.
	
