이 문제는 주어진 상황이 매우 단순한 문제이다.<br>
주어진 책에서 특정 단어가 몇 번이나 등장하는지 세는 아주 간단한(?)문제이다.<br>
문제에서 힌트로 준 것은 단어가 겹칠 수 있다는 것이다.<br>
만약 책이 ABABA이고, 단어가 ABA이면 가운데 A가 두 번 들어가게 된다.<br>
<br>
단순히 모든 책의 문자를 돌면서 단어만큼 확인하면 될 것 같지만, 이상하게도 단?어가 10만글자까지 들어올 수 있다.<br>
이런 brute force로는 절대 풀 수 없다.<br>
그래서 사용할 수 있는 방법이 두가지로 KMP와 라빈-카프 알고리즘이다.<br>
<br>
KMP는 문자열내에 문자열를 확인하는 알고리즘이다.<br>
이 알고리즘에서 중요한 것은 prefix와 suffix이다.<br>
문제에서 힌트로 줬던 것처럼 prefix와 suffix가 똑같다면 찾는 단어가 겹쳐 있을 수 있기 때문에 그 부분부터 이어서 찾아야 한다.<br>
<br>
그래서 우선 찾을 단어를 쭉 탐색하면서 0~i번째까지 같았지만 i + 1에서 틀린 경우, i번째까지의 prefix와 suffix가 같은 곳을 저장한다.<br>
이후 책을 쭉 탐색하면서 단어와 비교한다.<br>
지금 보고 있는 책의 글자와 단어의 글자가 같은데, 단어의 끝까지 왔다면 단어를 책에서 찾은 것이다.<br>
만약 다르다면 지금까지 본 글자수대로 prefix와 suffix가 같은 곳을 찾아 다시 탐색을 시작한다.<br>
<br>
라빈-카프 알고리즘은 hashing을 이용한다.<br>
책과 단어가 숫자, 대소문자로 구성되므로 총 62개의 문자가 존재한다. 각각 0부터 61까지의 code를 부여하고, 이를 자리수로 사용하도록 상수를 정해야 한다.<br>
그래서 62보다 큰 가까운 소수인 67을 정했고, 67진수처럼 hashing을 했다.<br>
즉, i번째 자리는 code * 67^(i-1)이다.<br>
물론 이렇게 하면 무조건 overflow가 일어나므로 적당한 수 1000000007로 나눈 나머지를 사용했다.<br>
<br>
이 방법이 가능한 이유는 처음 한 번 책의 초기부분의 hash를 구할 때만 단어의 길이 만큼 연산을 하고<br>
그 뒤로는 가장 앞자리를 제거하고 한 칸씩 자리수를 민 뒤 1의 자리를 추가하는 식으로<br>
단 두 번의 연산으로 다음 hash를 구할 수 있기 때문이다.<br>
이런 알고리즘은 잘 몰랐기 때문에 이 문제를 이해하고 나서 확실히 기억하도록 해야겠다.<br>
